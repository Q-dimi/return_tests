

<div id = 'errors'></div>



<script>

/*
  @param {developer_input}: developers input data ***
  @param {tests}: array of objects to run tests ***
  @param {allowed_types}: allowed return types ***
  @param {allowed_values}: allowed return values ***
  @param {regex_set}: allowed regular expressions ***
  @param {function_called}: function passed from client with parameters passed via dev ***
*/


const developer_input =  { 

  tests: [  
    {index_of_set: 1, a: 2, b: 5},
    {index_of_set: 2, a: 7, b: 5},
    {index_of_set: 3, a: 'hellow', b: 13},
    {index_of_set: 4, a: 2, b: 5},
    {index_of_set: 5, a: 2, b: 3}
  ],
    
  allowed_types: { 
    on: true, 
    values: ['number', 'BigInt'] 
  },  
    
  allowed_values: { 
    on: true, 
    values: [7, 12] 
  },
    
  regex_set: { 
    on: true, 
    values: ['[1-9]|10', '[1-10]', '[5-9]|10'] 
  }, 
    
  function_called: 
     function (a, b) {
      try { 
        return a + b; 
      } catch(err) {
        return err.message; 
      } 
    }

}

const tests = developer_input.tests;
const allowed_types = developer_input.allowed_types; 
const allowed_values = developer_input.allowed_values; 
const regex_set = developer_input.regex_set; 
const function_called = developer_input.function_called;

/*
  @param {error_set}: exported set of objects that did not pass test
  @param {error_text}: error text exported
*/

var error_sets = [];
var error_text = '';

/*
  check tests
*/

for(let i = 0; i < tests.length; i++) { 
  
  var params = [];
  
  for (const [key, value] of Object.entries(tests[i])) {
   if(key === 'index_of_set') continue;
   params.push(value);
  }
  
  var return_value = function_called(...params);
  var err_object = tests[i];
  var error_count = 0;
  
  if(allowed_types.on === true) {
    
    if(allowed_types.values.includes(typeof(return_value)) !== true) {
      
      err_object.error_type = true;
      
      err_object.error_type_message = `The value returned is not within the allowed types.`;
      
      err_object.error_type_rtype = typeof(return_value);
      
      err_object.error_type_value = return_value;
      
      error_count++;
      
    }
    
  }
  
  if(allowed_values.on === true) {
        
    if(
      typeof(return_value) === 'number' || 
      typeof(return_value) === 'BigInt' || 
      typeof(return_value) === 'string' ||  
      typeof(return_value) === 'undefined' ||  
      typeof(return_value) === 'null' ||
      typeof(return_value) === 'boolean'
    ) {
    
      if(allowed_values.values.includes(return_value) !== true) { 

        err_object.error_value = true;

        err_object.error_value_message = `The value returned is not within the allowed values.`;

        err_object.error_value_rvalue = return_value;
        
        err_object.error_value_type = typeof(return_value);

        error_count++;
        
      }

     } else if(typeof(return_value) === 'object') { 
       
       var match = false;
     
       for(let i = 0; i < allowed_values.values.length; i++) { 
           
         if(typeof(allowed_values.values[i]) === 'object') {
          if(JSON.stringify(allowed_values.values[i]).trim() === JSON.stringify(return_value).trim()) { 
            match = true;
            break;
          }
         }
       
       }
       
       if(match === false) { 
         
        err_object.error_value = true;

        err_object.error_value_message = `The value returned is not within the allowed values.`;
         
        err_object.error_value_rvalue = return_value;

        err_object.error_value_type = typeof(return_value);

        error_count++;
       
       }
     
     } else { 
       
       console.log(`
        error: the only allowed types are number, BigInt, string, boolean, undefined, null and object
       `);
     
     }
    
  }
  
  var regex_pass = false;
  
  if(regex_set.on === true) {
    
    for(let i = 0; i < regex_set.values.length; i++) { 
      
      var test_regex = test(regex_set.values[i], return_value);
      
      if(test_regex !== true) { 
        
        if(regex_pass === false) { 
          err_object.error_regex = true;
          regex_pass = true; 
        };
        
        err_object[`error_regex_message-${i}`] = `The value returned does not pass`;
        
        err_object[`error_regex_regular_expression-${i}`] = regex_set.values[i];
        
        err_object[`error_regex_return_value-${i}`] = return_value;
        
        err_object[`error_regex_returned_rejex-${i}`] = test_regex;
        
        error_count++;
        
      }
      
    }
    
  }
  
  if(error_count > 0) { 
    error_sets.push(err_object);
  }
  
}

/*
  @param {regular_expression}: regular expression being tested
  @param {total}: the value being tested against
*/

function test(regular_expression, return_value) { 
  try {
    return new RegExp(regular_expression).test(return_value);
  } catch(err) { 
    return err.message;
  } 
}

/*
  filling error_text
*/

for(let i = 0; i < error_sets.length; i++) { 
    error_text += `${JSON.stringify(error_sets[i])}  <br><br><br>`;
}

// console.log(error_text); //******************* all parameter sets returned with errors
document.getElementById('errors').innerHTML= error_text;
  
  
</script>